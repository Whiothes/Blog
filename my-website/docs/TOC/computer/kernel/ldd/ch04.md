# 第四章 调试技术

## 内核中的调试支持

```sh
make menuconfig

> kernel hacking
```

## 通过打印调试

### `printk`

- KERN_EMERG

紧急事件消息，一般是系统崩溃之前提示的消息

- KERN_ALERT

需要立即采取动作的情况

- KERN_CRIT

临界状态，通常涉及严重的硬件或软件操作失败

- KERN_ERR

用于报告错误状态。设备驱动程序会经常使用KERN_ERR来报告来自硬件的问题

- KERN_WARNING

对可能出现问题的情况进行警告，但这类情况通常不会对系统造成严重问题

- KERN_NOTICE

有必要进行提示的正常情形。许多与安全相关的善用这个级别进行汇报

- KERN_INFO

提示性信息

- KERN_DEBUG

用于调试信息



未指定优先级的默认级别是`DEFAULT_MESSAGE_LOGLEVEL`，定义在`kernel/printk.c`

可以 `echo (1-8) > /proc/sys/kernel/printk` 针内核消息显示到控制台上（**存疑**）



### 重定向控制台消息

内核可以将消息发送到一个指定的虚拟控制台。任何一个控制台设备可以调用`ioctl(TIOCLINUX)`指定接收消息的其他虚拟终端。

```c
int main(int argc, char **argv)
{
	char bytes[2] = {11, 0};

	if (argc == 2)
		　bytes[1] = atoi(argv[1]);
	else {
		fprintf(stderr, "%s: need a single arg\n", argv[0]);
		exit(1);
	}

	if (ioctl(STDIN_FILENO, TIOCLINUX, bytes) < 0) {
		fprintf(stderr,
			"%s: ioctl(stdin, TIOCLINUX): %s\n",
			argv[0],
			strerror(errno));
	}
	exit(0);
}
```

### 消息如何被记录

将消息写到长度为$4 \text{KB} < \text{\_\_LOG\_BUF\_LEN} < 1\text{MB}$字节的循环缓冲区中。然后唤醒任何一个睡眠在`syslog`系统调用上的进程，或正在读取/proc/kmsg的进程。**对/proc/kmsg进行读操作时，日志缓冲区中被读取的数据就不再保留**，而`syslog`可以通过选项返回日志数据并保存。`dmesg`命令可以在不刷新缓冲区的情况下获取内容

`klogd`运行时会读取内核消息并分发到`syslogd`，`syslogd`查看`/etc/syslog.conf`找出处理方法

`klogd`可以指定`-f` 将消息保存到特定文件，或者修改`/etc/syslog.conf`。

### 开启及关闭消息

- 可以通过在宏名字中删减或增加一个字母来启用或禁用每一条打印语句。
- 在编译前修改CFLAGS变量，一次性禁用所有消息
- 使用宏进行区分管理

以下使用PDEBUG宏在定义了SCULL_DEBUG宏后为打印行为在内核空间和用户空间调用不同的函数， 否则 什么也不做

```c
#undef PDEBUG
#ifdef SCULL_DEBUG

#ifdef __KERNEL__ /* kernel mode */
#define PDEBUG(fmt, args...) printk(KERN_DEBUG "scull: " fmt, ##args)
#else
#define PDEBUG(fmt, args...) fprintf(stderr, fmt, ##args)
#endif

#else

#define PDEBUG(fmt, args...)

#endif

#undef PDEBUG
#define PDEBUG(fmt, args...)
```

makefile:

```makefile
DEBUG = y # uncomment to disable debugging

ifeq ($(DEBUG),y)
	DEBFLAGS = -O -g -DSCULL_DEBUG # "-O" is needed to expand inlines
else
	DEBFLAGS = -O2
endif

CFLAGS += $(DEBFLAGFS)
```

### 速度限制

`printk_ratelimit`跟踪发送到控制台的消息数量。如果超出阈值 ，将返回零，从而避免发送重复消息。

```c
if (prinkt_ratelimit())
	prinkt(KERN_NOTICE "The printer is still on fire\n");
```


可以通过`/proc/sys/kernel/printk_ratelimit`（重新打开消息之前应该等待的秒数）、`/proc/sys/kernel/printk_ratelimit_burst`（进行速度限制之前 可以接受的消息数）定义行为

### 打印设备编号

`<linux/kdev_t.h>`

```c
/* return characters' number */
int prink_dev_t(char *buffer, dev_t dev);

/* return buffer area */
char *format_dev_t(char *buffer, dev_t dev);
```

