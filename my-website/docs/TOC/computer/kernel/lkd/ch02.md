# 第 2 章 从内核出发 #

## 2.2 内核源码树 ##


| 目录          | 描述                             |
|---------------|----------------------------------|
| arch          | 特定体系结构的源码               |
| block         | 块设备 I/O 层                    |
| crypto        | 加密 API                         |
| Documentation | 内核源码文档                     |
| drivers       | 设备驱动程序                     |
| firmware      | 使用某些驱动程序而需要的设备固件 |
| fs            | VFS 和各种文件系统               |
| include       | 内核头文件                       |
| init          | 内核引导和初始化                 |
| ipc           | 进程间通信代码                   |
| kernel        | 像调度程序这样的核心子系统       |
| lib           | 通用内核函数                     |
| mm            | 内存管理子系统和VM               |
| net           | 网络子系统                       |
| samples       | 示例, 示范代码                   |
| scripts       | 编译内核所用的脚本               |
| security      | Linux 安全模块                   |
| sound         | 语音子系统                       |
| usr           | 早期用户空间代码                 |
| tools         | 在 Linux 开发中有用的工具        |
| virt          | 虚拟化基础结构                   |

_Figure 2.1 内核源码树的根目录描述_



## 2.3 编译内核 ##

### 2.3.1 配置内核 ###

配置内核编译选项, 以下命令之一:
```bash
# 命令行工具, 逐个选择yes/no
make config

# ncurse 库的图形化工具
make menuconfig

# gtk+ 的图形化工具
make gconfig

# 默认配置
make defconfig

# 验证和更新配置
make oldconfig
```

配置完成, 开始编译
```bash
make
```

`CONFIG_IKCONFIG_PROC` 把完整的压缩过的内核配置文件存放在 `/proc/config.gz`


### 2.3.2 减少编译的垃圾信息 ###

减少看到的垃圾信息, 保留错误报告与警告信息, 将信息重定向到此文件:
```bash
make > ../detritus
```

不需要保留编译信息的文件
```bash
make > /dev/null
```

### 2.3.3 多线程编译 ###
n 为线程数, 一般可以是进程核心数或核心数x2
```bash
make -jn    
```

### 2.3.4 安装新内核 ###

以 `root` 身份执行以下命令, 可以把所有已编译的模块安装到正确的主目录 `/lib/modules` 下
```bash
make modules_install
```

## 2.4 内核开发的特点 ##

- 内核编程时既不能访问 C 库也不能访问标准的 C 头文件
- 内核编程时必须使用GNU C
- 内核编程时缺乏像用户空间那样的内存保护机制
- 内核编程时难以执行浮点运行
- 内核给每个进程只有一个很小的定长堆栈.
- 由于内核支持异步中断, 抢占和SMP, 因此必须时刻注意同步和并发.
- 要考虑可移植性的重要性.

### 2.4.1 无libc库抑或无标准头文件 ###

`printf` 与 `printk` 的显著区别是 `printk` 允许指定一个标志设置优先级. syslogd 会根据这个优先级标志来决定在什么地方显示消息.

### 2.4.2 GNU C ###

1. 内联 (`inline`) 函数

函数会在所调用的位置展开. 可以消除函数调用和返回所带来的开销(寄存器存储和恢复), 但是代码会变长, 占用更多的内存空间或更多的指令缓存. 
通常把对时间要求比较高, 而本身长度又比较短的函数定义成内联函数.

```c
static inline void wolf(unsigned long tail_size);
```

内联函数必须在使用之前定义. 实践中一般在头文件中定义内联函数.

2. 内联汇编

gcc 编译器支持在 C 函数中嵌入汇编指令.
我们通常使用 `asm()` 指令嵌入汇编代码. 下面这条内联汇编指令用于执行x86处理器的rdtsc指令, 返回时间戳(tsc)寄存器的值:

```c
unsigned int low, high;
asm volatile("rdtsc" : "=a" (low), "=d" (high));
```

3. 分支声明

把选择标记为绝少发生的分支:
```c
/* 我们认为 error 绝大多数时间都会为0 */
if (unlikely(error)) {
        /* .... */
}
```

把一个分支标记为通常为真的选择:
```c
/* 我们认为success通常不会为0 */
if (likely(success)) {
        /* ... */
}
```

### 2.4.3 没有内存保护机制 ###

用户程序试图非法访问内存, 内核会发送 SIGSEGV 信号并结束进程. 但是内核非法访问内存则无法控制

### 2.4.4 不要轻易在内核中使用浮点数 ###

### 2.4.5 容积小而固定的栈 ###

用户空间的程序可以从栈上分配大量的空间来存放变量, 甚至巨大的结构体或者是包含数以千计的数据项的数组.
但是内核栈的大小是2页, 即32位机上是8KB, 64 位机上是16 KB.

### 2.4.6 同步和并发 ###

- Linux 是抢占多任务操作系统. 内核的进程调度程序即兴对进程进行调度和重新调度. 内核必须和这些任务同步.
- Linux 内核支持对称多处理系统(SMP). 同时在两个或两个以上的处理器上执行的内核代码可能会同时访问共享一个资源.
- 中断是异步到来的, 完全不顾及当前正在执行的代码. 即中断可能在代码访问资源时到来, 中断处理程序就有可能访问同一个资源.
- Linux 内核可以抢占. 内核中一段正在执行的代码可能会被另外一段抢占, 从而有可能导致几段代码同时访问相同的资源.

常用的解决竞争的办法是自旋锁和信号量.

### 2.4.7 可移植性的重要性 ###

Linux 是一个可移植的操作系统, 大部分 C 代码应该与体系结构无关.
