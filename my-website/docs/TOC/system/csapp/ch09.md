import {Tex} from 'react-tex'

# Chapter 9. Virtual Memory #


## 9.1 Physical and Virtual Addressing ##

    The main memory of a computer is organized as an *array* of _M_ contiguous byte-size cells.
    


<div style={{textAlign:'center'}}>

![](img/ch09/fig9.1.svg)

_Figure 9.1 A system that uses physical addressing._
</div>


<br/>
<br/>

<div style={{textAlign:'center'}}>

![](img/ch09/fig9.2.svg)

_Figure 9.2  A system that uses virtual addressing_
</div>


the CPU access main memory by generating a _virtual address (VA)_ converted to physical address by 
_address translation_ in MMU.


## 9.2 Address Spaces ##

An _address space_ is an __ordered set of nonnegative interge__ addresses

<div style={{textAlign:'center'}}>

{0, 1, 2, ...}
</div>

## 9.3 VM as a Tool for Cache ##

the set of virtual pages is partitioned into three disjoint subsets:
- Unallocated: Pages that have not yet been allocated (or created) by the VM system. do not have any data associated with them, and thus do not occupy any space on disk.
- Cached: Allocated pages that currently cached in physical memory.
- Uncached: Allocated pages that are not cached in physical memory.


<div style={{textAlign:'center'}}>

![](img/ch09/fig9.3.svg)

_Figure 9.3 How a VM system uses main memory as a cache_
</div>



### 9.3.2 Page Tables ###

if cached, VM system must have way to determine which physical page it is cached in.

if missed, select a victim page in physical memory, and copy the virtual page from disk to DRAM, replace the victim page.

- PTEs: _page table entries_
- VPs: _virtual pages_

<div style={{textAlign:'center'}}>

![](img/ch09/fig9.4.svg)

_Figure 9.4 Page table._
</div>


### 9.3.3 Page Hits ###

<div style={{textAlign:'center'}}>

![](img/ch09/fig9.5.svg)

_Figure 9.5 VM page hit_
</div>

### 9.3.4 Page Faults ###

a DRAM cache miss is known as a _page fault_.


<div style={{textAlign:'center'}}>

![](img/ch09/fig9.6.svg)

_Figure 9.6 VM page fault (before)_

</div>
The reference to a word in VP 3 is a miss and triggers a page fault.

<br/>
<br/>
<br/>

<div style={{textAlign:'center'}}>

![](img/ch09/fig9.7.svg)

_Figure 9.7 VM page fault (after)_

</div>

The page faults:
1. selects VP 4 as the victim (If VP 4 has been modified, then the kernel copies it back to disk).
2. replaces it with a copy of VP 3 from disk.

The kernel:
1. copies VP 3 from disk to PP 3 in memory
2. updates PTE 3,
3. VP 3 now cached in main memory

### 9.3.5 Allocating Pages ###

<div style={{textAlign:'center'}}>

![](img/ch09/fig9.8.svg)

_Figure 9.8 Allocating a new virtual page_
</div>



### 9.3.6 Locality to the Rescue Again ###

<div style={{textAlign:'center'}}>

![](img/ch09/fig9.9.svg)

_Figure __9.9 How VM provides processes with separate address spaces.__The operating system matains a separate page table for each process in the system_
</div>


## 9.5 VM as a Tool for memory Protection ##

A user process should not be allowed to:
- modify its read-only code section. 
- read or modify any of the code and data structures in the kernel.
- read or write the private memory of other process,
- modify any virtual pages that are shared with other process, unless all partiies explicitly allow it .


permission bits:
- SUP: whther process must be running in kernel (supervisor) mode to access the page. user mode process can only access pages with SUP is 0.
- READ/WRITE: read or write

<div style={{textAlign:'center'}}>

![](img/ch09/fig9.10.svg)

_Figure 9.10 Using VM to provide page-level memory protection_
</div>

## 9.6 Address Translation ##

<div style={{display: 'flex', justifyContent: 'center'}}>

<table align="center">
<tr> <th>Symbol</th> <th>Description</th> </tr>
<tr> <td colspan="2">Basic parameters</td> </tr>
<tr> <td> <Tex texContent="N=2^n"/>              </td> <td> Number of addresses in virtual address space  </td> </tr>
<tr> <td> <Tex texContent="M=2^m" />             </td> <td> Number of addresses in physical address space </td> </tr>
<tr> <td> <Tex texContent="P=2^p" />             </td> <td> Page size (bytes)                             </td> </tr>
<tr> <td colspan="2"> Components of a virtual addresses (VA)                                              </td> </tr>
<tr> <td> VPO                                    </td> <td> Virtual page offset (bytes)                   </td> </tr>
<tr> <td> VPN                                    </td> <td> Virutal page number                           </td> </tr>
<tr> <td> TLBI                                   </td> <td> TLB index                                     </td> </tr>
<tr> <td> TLBT                                   </td> <td> TLB tag                                       </td> </tr>
<tr> <td colspan="2"> Components of a physical address (PA)                                               </td> </tr>
<tr> <td> PPO                                    </td> <td> Physical page offset (bytes)                  </td> </tr>
<tr> <td> PPN                                    </td> <td> Physical page number                          </td> </tr>
<tr> <td> CO                                     </td> <td> Byte offset within cache block                </td> </tr>
<tr> <td> CI                                     </td> <td> Cache index                                   </td> </tr>
<tr> <td> CT                                     </td> <td> Cache tag                                     </td> </tr>
</table>
</div>
<div style={{textAlign:'center'}}>

_Figure 9.11 Summary of address translation symbols._
</div>

<br/>
<br/>


<div style={{textAlign:'center'}}>

![](img/ch09/fig9.12.svg)

_Figure 9.12 Addres translation with a page table_
</div>


<br/>
<br/>

<div style={{textAlign:'center'}}>

![](img/ch09/fig9.13.svg)

_Figure 9.13 Operational view of page hits and paeg faults. VA: virtual address. PTEA: page table entry address: PTE: page table entry. PA physical address_
</div>



CPU hardware performs when there is a page hit.
1. The processor generates a virtual address and sends it to the MMU.
2. The MMU generates the PTE address and requests it from the cache/main memory.
3. The cache/main memory returns the PTE to the MMU.
4. The MMU constructs the physical address and sends it to the cache/main memory.
5. The cache/main memory returns the requested data word to the processor.
