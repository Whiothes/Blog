"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1573],{25906:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>q,contentTitle:()=>o,default:()=>h,frontMatter:()=>m,metadata:()=>s,toc:()=>u});const s=JSON.parse('{"id":"TOC/computer/Code Pieces/Data Structure/circular queue","title":"Circular Queue && Shared Memory","description":"Definitions","source":"@site/docs/TOC/computer/Code Pieces/Data Structure/circular queue.md","sourceDirName":"TOC/computer/Code Pieces/Data Structure","slug":"/TOC/computer/Code Pieces/Data Structure/circular queue","permalink":"/docs/TOC/computer/Code Pieces/Data Structure/circular queue","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"\u7b2c 3 \u7ae0 \u67e5\u627e","permalink":"/docs/TOC/computer/Algorithms/Algorithms/ch03"},"next":{"title":"Programming Language","permalink":"/docs/category/programming-language"}}');var r=t(74848),i=t(28453);const m={},o="Circular Queue && Shared Memory",q={},u=[{value:"Definitions",id:"definitions",level:2},{value:"Implementations",id:"implementations",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",pre:"pre",ul:"ul",...(0,i.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"circular-queue--shared-memory",children:"Circular Queue && Shared Memory"})}),"\n",(0,r.jsx)(e.h2,{id:"definitions",children:"Definitions"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"shmqueue.h"}),":"]}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-c",children:"#ifndef SHMQUEUE_H\n#define SHMQUEUE_H\n\n#include <stdbool.h>\n#include <stddef.h>\n\nstruct shmqueue;\n\nbool shmq_check_memory(const struct shmqueue *q);\nvoid shmq_free_memory(struct shmqueue **q);\nstruct shmqueue *\nshmq_get_memory(const char *filename, const int size, const int width);\n\nint shmq_data_total_memory(const struct shmqueue *q);\n\nint shmq_size(const struct shmqueue *q);\nint shmq_front(const struct shmqueue *q);\nint shmq_rear(const struct shmqueue *q);\nint shmq_width(const struct shmqueue *q);\nvoid *shmq_data_at(const struct shmqueue *q, const int idx);\n\nbool shmq_isfull(const struct shmqueue *q);\nbool shmq_isempty(const struct shmqueue *q);\n\nvoid *shmq_dequeue(struct shmqueue *q);\nint shmq_enqueue(struct shmqueue *q, const void *data);\n\nbool shmq_has_data(const struct shmqueue *q,\n     const void *data,\n     int (*compar)(const void *, const void *, size_t n));\n\nint shmq_enqueue_unique(struct shmqueue *q,\n   const void *data,\n   int (*compar)(const void *, const void *, size_t n));\n\nconst char *shmq_strerror();\n#endif\n"})}),"\n",(0,r.jsx)(e.h2,{id:"implementations",children:"Implementations"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.code,{children:"shmqueue.c"})}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-c",children:'#include "shmqueue.h"\n#include <stdbool.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <errno.h>\n\n#define SHMQ_ERR_OPEN  -1\n#define SHMQ_ERR_TRUNC  -2\n#define SHMQ_ERR_MMAP  -3\n#define SHMQ_ERR_MEM_CHECK_FAIL -4\n#define SHMQ_ERR_DATA_DUP -5\n#define SHMQ_ERR_INDEX_OUTRANGE -6\n\n#ifndef NAME_MAX\n#define NAME_MAX 255\n#endif\n\nstruct shmqueue {\n int size;\n int front;\n int rear;\n int width;\n void *data;\n};\n\n__thread int shmq_errnum;\n\nstatic int\n__shmq_set_settings(struct shmqueue *q, const int size, const int width)\n{\n if (!q) {\n  return -1;\n }\n\n q->size = size;\n q->front = -1;\n q->rear = -1;\n q->width = width;\n}\n\nstatic bool __shmq_mmap_check(const void *ptr)\n{\n return ptr && ptr != MAP_FAILED;\n}\n\nstatic bool __shmq_index_check(const struct shmqueue *q)\n{\n bool ok = false;\n\n if (!shmq_check_memory(q)) {\n  return false;\n }\n\n ok = (q->front >= -1 && q->front < q->size) &&\n      (q->rear >= -1 && q->rear < q->size);\n\n if (!ok) {\n  shmq_errnum = SHMQ_ERR_INDEX_OUTRANGE;\n }\n\n return ok;\n}\n\nbool shmq_check_memory(const struct shmqueue *q)\n{\n bool ok = __shmq_mmap_check(q) && __shmq_mmap_check(q->data);\n if (!ok) {\n  shmq_errnum = SHMQ_ERR_MEM_CHECK_FAIL;\n }\n\n return ok;\n}\n\nvoid shmq_free_memory(struct shmqueue **q)\n{\n if (__shmq_mmap_check(*q)) {\n  if (__shmq_mmap_check((*q)->data)) {\n   munmap((*q)->data, ((*q)->size+1) * (*q)->width);\n   (*q)->data = NULL;\n  }\n  munmap(*q, sizeof(**q));\n  *q = NULL;\n }\n}\n\nstruct shmqueue *\nshmq_get_memory(const char *filename, const int size, const int width)\n{\n char *ptr = NULL;\n int shmid1, shmid2;\n char shmqselfname[NAME_MAX], shmqdataname[NAME_MAX];\n struct shmqueue *q = NULL;\n int ret = 0;\n\n if (!filename || !filename[0]) {\n  goto null_return;\n }\n\n ptr = strrchr(filename, \'/\');\n if (ptr) {\n  snprintf(shmqselfname, NAME_MAX, "%s", ptr + 1);\n  snprintf(shmqdataname, NAME_MAX, "%s.", ptr + 1);\n } else {\n  snprintf(shmqselfname, NAME_MAX, "%s", filename);\n  snprintf(shmqdataname, NAME_MAX, "%s.", filename);\n }\n\n shmid1 = shm_open(shmqselfname, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);\n if (shmid1 == -1) {\n  shmq_errnum = SHMQ_ERR_OPEN;\n  goto null_return;\n }\n\n ret = ftruncate(shmid1, sizeof(*q));\n if (ret == -1) {\n  shmq_errnum = SHMQ_ERR_TRUNC;\n  goto null_return;\n }\n\n q = mmap(NULL,\n   sizeof(*q),\n   PROT_READ | PROT_WRITE,\n   MAP_SHARED | MAP_FILE,\n   shmid1,\n   0);\n if (!q) {\n  shmq_errnum = SHMQ_ERR_MMAP;\n  goto null_return;\n }\n\n if (q->size != size || q->width != width) {\n  __shmq_set_settings(q, size, width);\n }\n\n shmid2 = shm_open(shmqdataname, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);\n if (shmid2 == -1) {\n  shmq_errnum = SHMQ_ERR_OPEN;\n  goto null_return;\n }\n\n ret = ftruncate(shmid2, (size+1) * width);\n if (ret == -1) {\n  shmq_errnum = SHMQ_ERR_TRUNC;\n  goto null_return;\n }\n\n q->data = mmap(NULL,\n         (size + 1) * width,\n         PROT_READ | PROT_WRITE,\n         MAP_SHARED | MAP_FILE,\n         shmid2,\n         0);\n if (!q) {\n  shmq_errnum = SHMQ_ERR_MMAP;\n  goto null_return;\n }\n\nok:\n return q;\n\nnull_return:\n if (shmq_check_memory(q))\n  shmq_free_memory(&q);\n return NULL;\n}\n\nint shmq_size(const struct shmqueue *q)\n{\n if (shmq_check_memory(q)) {\n  return q->size;\n }\n return -1;\n}\n\nint shmq_front(const struct shmqueue *q)\n{\n if (shmq_check_memory(q)) {\n  return q->front;\n }\n return -1;\n}\n\nint shmq_rear(const struct shmqueue *q)\n{\n if (shmq_check_memory(q)) {\n  return q->rear;\n }\n return -1;\n}\n\nint shmq_width(const struct shmqueue *q)\n{\n if (shmq_check_memory(q)) {\n  return q->width;\n }\n return -1;\n}\n\nbool shmq_isfull(const struct shmqueue *q)\n{\n return (shmq_check_memory(q) && q->front != -1 && (q->rear + 1) % q->size == q->front);\n}\n\nbool shmq_isempty(const struct shmqueue *q)\n{\n return shmq_check_memory(q) && (q->front == -1);\n}\n\nint shmq_data_total_memory(const struct shmqueue *q)\n{\n if (shmq_check_memory(q)) {\n  return shmq_size(q) * shmq_width(q);\n }\n return -1;\n}\n\nvoid *shmq_dequeue(struct shmqueue *q)\n{\n void *ptr = NULL;\n\n if (shmq_check_memory(q) && q->front != -1) {\n  mlock(q, sizeof(*q));\n  mlock(q->data, (q->size + 1) * q->width);\n\n  ptr = q->data + (q->front * q->width);\n\n  if (q->front == q->rear) {\n   q->front = q->rear = -1;\n  } else {\n   q->front = (q->front + 1) % q->size;\n  }\n\n  munlock(q, sizeof(*q));\n  munlock(q->data, (q->size + 1) * q->width);\n\n  return ptr;\n }\n\n return NULL;\n}\n\nint shmq_enqueue(struct shmqueue *q, const void *data)\n{\n if (!shmq_check_memory(q)) {\n  return -1;\n }\n\n mlock(q, sizeof(*q));\n mlock(q->data, (q->size + 1) * q->width);\n\n if (shmq_isfull(q)) {\n  shmq_dequeue(q);\n } else if (q->front == -1) {\n  q->front = 0;\n }\n\n q->rear = (q->rear + 1) % q->size;\n\n if (!__shmq_index_check(q)) {\n  return -1;\n }\n\n memcpy((char*)q->data + (q->rear * q->width), data, q->width);\n msync(q->data, (q->size + 1) * q->width, MS_SYNC);\n\n munlock(q->data, (q->size + 1) * q->width);\n munlock(q, sizeof(*q));\n\n return q->rear;\n}\n\nint shmq_enqueue_unique(struct shmqueue *q,\n   const void *data,\n   int (*compar)(const void *, const void *, size_t n))\n{\n if (!shmq_check_memory(q)) {\n  return -1;\n }\n\n if (shmq_has_data(q, data, compar)) {\n  shmq_errnum = SHMQ_ERR_DATA_DUP;\n  return -1;\n }\n\n return shmq_enqueue(q, data);\n}\n\nvoid *shmq_data_at(const struct shmqueue *q, const int idx)\n{\n if (shmq_check_memory(q) == false || q->front == -1) {\n  return NULL;\n }\n\n return (char *)q->data + idx * (q->width);\n}\n\nbool shmq_has_data(const struct shmqueue *q,\n     const void       *data,\n     int (*compar)(const void *, const void *, size_t n))\n{\n bool ok;\n if (!shmq_check_memory(q) || shmq_isempty(q)) {\n  return false;\n }\n\n mlock(q->data, (q->size + 1) * q->width);\n mlock(q, sizeof(*q));\n\n int i = q->rear;\n if ((ok = (compar(shmq_data_at(q, i), data, q->width) == 0))) {\n  goto finish;\n }\n\n for (i = q->front; i != q->rear; i = (i + 1) % q->size) {\n  if ((ok = (compar(shmq_data_at(q, i), data, q->width) == 0))) {\n   goto finish;\n  }\n }\n\nfinish:\n\n munlock(q->data, (q->size + 1) * q->width);\n munlock(q, sizeof(*q));\n\n return ok;\n}\n\nconst char *shmq_strerror()\n{\n static char errmsg[256] = {0};\n switch (shmq_errnum) {\n case SHMQ_ERR_OPEN:\n  snprintf(errmsg,\n    sizeof(errmsg),\n    "%s: %s",\n    "shm_open failed",\n    strerror(errno));\n  break;\n\n case SHMQ_ERR_TRUNC:\n  snprintf(errmsg,\n    sizeof(errmsg),\n    "%s: %s",\n    "ftruncate failed",\n    strerror(errno));\n  break;\n\n case SHMQ_ERR_MMAP:\n  snprintf(errmsg,\n    sizeof(errmsg),\n    "%s: %s",\n    "mmap failed",\n    strerror(errno));\n  break;\n\n case SHMQ_ERR_MEM_CHECK_FAIL:\n  snprintf(errmsg,\n    sizeof(errmsg),\n    "%s: %s",\n    "shmq_check_memory failed",\n    strerror(errno));\n  break;\n\n case SHMQ_ERR_DATA_DUP:\n  snprintf(\n      errmsg, sizeof(errmsg), "shmqueue has the same data\\n");\n  break;\n\n case SHMQ_ERR_INDEX_OUTRANGE:\n  snprintf(\n      errmsg, sizeof(errmsg), "check shmqueue index failed\\n");\n  break;\n\n default:\n  snprintf(errmsg, sizeof(errmsg), "%s", "success");\n  break;\n }\n\n return errmsg;\n}\n'})})]})}function h(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(c,{...n})}):c(n)}},28453:(n,e,t)=>{t.d(e,{R:()=>m,x:()=>o});var s=t(96540);const r={},i=s.createContext(r);function m(n){const e=s.useContext(i);return s.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:m(n.components),s.createElement(i.Provider,{value:e},n.children)}}}]);