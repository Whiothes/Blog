"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1573],{56033:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>q,contentTitle:()=>o,default:()=>h,frontMatter:()=>m,metadata:()=>s,toc:()=>u});const s=JSON.parse('{"id":"TOC/computer/Code Pieces/Data Structure/circular queue","title":"Circular Queue && Shared Memory","description":"Definitions ##","source":"@site/docs/TOC/computer/Code Pieces/Data Structure/circular queue.md","sourceDirName":"TOC/computer/Code Pieces/Data Structure","slug":"/TOC/computer/Code Pieces/Data Structure/circular queue","permalink":"/docs/TOC/computer/Code Pieces/Data Structure/circular queue","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"\u7b2c 3 \u7ae0 \u67e5\u627e","permalink":"/docs/TOC/computer/Algorithms/Algorithms/ch03"},"next":{"title":"Programming Language","permalink":"/docs/category/programming-language"}}');var r=e(74848),i=e(28453);const m={},o="Circular Queue && Shared Memory",q={},u=[{value:"Definitions",id:"definitions",level:2},{value:"Implementations",id:"implementations",level:2}];function c(t){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",pre:"pre",ul:"ul",...(0,i.R)(),...t.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"circular-queue--shared-memory",children:"Circular Queue && Shared Memory"})}),"\n",(0,r.jsx)(n.h2,{id:"definitions",children:"Definitions"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"shmqueue.h"}),":"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"#ifndef SHMQUEUE_H\n#define SHMQUEUE_H\n\n#include <stdbool.h>\n#include <stddef.h>\n\nstruct shmqueue;\n\nbool shmq_check_memory(const struct shmqueue *q);\nvoid shmq_free_memory(struct shmqueue **q);\nstruct shmqueue *\nshmq_get_memory(const char *filename, const int size, const int width);\n\nint shmq_data_total_memory(const struct shmqueue *q);\n\nint shmq_size(const struct shmqueue *q);\nint shmq_front(const struct shmqueue *q);\nint shmq_rear(const struct shmqueue *q);\nint shmq_width(const struct shmqueue *q);\nvoid *shmq_data_at(const struct shmqueue *q, const int idx);\n\nbool shmq_isfull(const struct shmqueue *q);\nbool shmq_isempty(const struct shmqueue *q);\n\nvoid *shmq_dequeue(struct shmqueue *q);\nint shmq_enqueue(struct shmqueue *q, const void *data);\n\nbool shmq_has_data(const struct shmqueue *q,\n\t\t   const void *data,\n\t\t   int (*compar)(const void *, const void *, size_t n));\n\nint shmq_enqueue_unique(struct shmqueue *q,\n\t\t\tconst void *data,\n\t\t\tint (*compar)(const void *, const void *, size_t n));\n\nconst char *shmq_strerror();\n#endif\n"})}),"\n",(0,r.jsx)(n.h2,{id:"implementations",children:"Implementations"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"shmqueue.c"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'#include "shmqueue.h"\n#include <stdbool.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <errno.h>\n\n#define SHMQ_ERR_OPEN\t\t-1\n#define SHMQ_ERR_TRUNC\t\t-2\n#define SHMQ_ERR_MMAP\t\t-3\n#define SHMQ_ERR_MEM_CHECK_FAIL -4\n#define SHMQ_ERR_DATA_DUP\t-5\n#define SHMQ_ERR_INDEX_OUTRANGE -6\n\n#ifndef NAME_MAX\n#define NAME_MAX 255\n#endif\n\nstruct shmqueue {\n\tint size;\n\tint front;\n\tint rear;\n\tint width;\n\tvoid *data;\n};\n\n__thread int shmq_errnum;\n\nstatic int\n__shmq_set_settings(struct shmqueue *q, const int size, const int width)\n{\n\tif (!q) {\n\t\treturn -1;\n\t}\n\n\tq->size = size;\n\tq->front = -1;\n\tq->rear = -1;\n\tq->width = width;\n}\n\nstatic bool __shmq_mmap_check(const void *ptr)\n{\n\treturn ptr && ptr != MAP_FAILED;\n}\n\nstatic bool __shmq_index_check(const struct shmqueue *q)\n{\n\tbool ok = false;\n\n\tif (!shmq_check_memory(q)) {\n\t\treturn false;\n\t}\n\n\tok = (q->front >= -1 && q->front < q->size) &&\n\t     (q->rear >= -1 && q->rear < q->size);\n\n\tif (!ok) {\n\t\tshmq_errnum = SHMQ_ERR_INDEX_OUTRANGE;\n\t}\n\n\treturn ok;\n}\n\nbool shmq_check_memory(const struct shmqueue *q)\n{\n\tbool ok = __shmq_mmap_check(q) && __shmq_mmap_check(q->data);\n\tif (!ok) {\n\t\tshmq_errnum = SHMQ_ERR_MEM_CHECK_FAIL;\n\t}\n\n\treturn ok;\n}\n\nvoid shmq_free_memory(struct shmqueue **q)\n{\n\tif (__shmq_mmap_check(*q)) {\n\t\tif (__shmq_mmap_check((*q)->data)) {\n\t\t\tmunmap((*q)->data, ((*q)->size+1) * (*q)->width);\n\t\t\t(*q)->data = NULL;\n\t\t}\n\t\tmunmap(*q, sizeof(**q));\n\t\t*q = NULL;\n\t}\n}\n\nstruct shmqueue *\nshmq_get_memory(const char *filename, const int size, const int width)\n{\n\tchar *ptr = NULL;\n\tint shmid1, shmid2;\n\tchar shmqselfname[NAME_MAX], shmqdataname[NAME_MAX];\n\tstruct shmqueue *q = NULL;\n\tint ret = 0;\n\n\tif (!filename || !filename[0]) {\n\t\tgoto null_return;\n\t}\n\n\tptr = strrchr(filename, \'/\');\n\tif (ptr) {\n\t\tsnprintf(shmqselfname, NAME_MAX, "%s", ptr + 1);\n\t\tsnprintf(shmqdataname, NAME_MAX, "%s.", ptr + 1);\n\t} else {\n\t\tsnprintf(shmqselfname, NAME_MAX, "%s", filename);\n\t\tsnprintf(shmqdataname, NAME_MAX, "%s.", filename);\n\t}\n\n\tshmid1 = shm_open(shmqselfname, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);\n\tif (shmid1 == -1) {\n\t\tshmq_errnum = SHMQ_ERR_OPEN;\n\t\tgoto null_return;\n\t}\n\n\tret = ftruncate(shmid1, sizeof(*q));\n\tif (ret == -1) {\n\t\tshmq_errnum = SHMQ_ERR_TRUNC;\n\t\tgoto null_return;\n\t}\n\n\tq = mmap(NULL,\n\t\t sizeof(*q),\n\t\t PROT_READ | PROT_WRITE,\n\t\t MAP_SHARED | MAP_FILE,\n\t\t shmid1,\n\t\t 0);\n\tif (!q) {\n\t\tshmq_errnum = SHMQ_ERR_MMAP;\n\t\tgoto null_return;\n\t}\n\n\tif (q->size != size || q->width != width) {\n\t\t__shmq_set_settings(q, size, width);\n\t}\n\n\tshmid2 = shm_open(shmqdataname, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);\n\tif (shmid2 == -1) {\n\t\tshmq_errnum = SHMQ_ERR_OPEN;\n\t\tgoto null_return;\n\t}\n\n\tret = ftruncate(shmid2, (size+1) * width);\n\tif (ret == -1) {\n\t\tshmq_errnum = SHMQ_ERR_TRUNC;\n\t\tgoto null_return;\n\t}\n\n\tq->data = mmap(NULL,\n\t\t       (size + 1) * width,\n\t\t       PROT_READ | PROT_WRITE,\n\t\t       MAP_SHARED | MAP_FILE,\n\t\t       shmid2,\n\t\t       0);\n\tif (!q) {\n\t\tshmq_errnum = SHMQ_ERR_MMAP;\n\t\tgoto null_return;\n\t}\n\nok:\n\treturn q;\n\nnull_return:\n\tif (shmq_check_memory(q))\n\t\tshmq_free_memory(&q);\n\treturn NULL;\n}\n\nint shmq_size(const struct shmqueue *q)\n{\n\tif (shmq_check_memory(q)) {\n\t\treturn q->size;\n\t}\n\treturn -1;\n}\n\nint shmq_front(const struct shmqueue *q)\n{\n\tif (shmq_check_memory(q)) {\n\t\treturn q->front;\n\t}\n\treturn -1;\n}\n\nint shmq_rear(const struct shmqueue *q)\n{\n\tif (shmq_check_memory(q)) {\n\t\treturn q->rear;\n\t}\n\treturn -1;\n}\n\nint shmq_width(const struct shmqueue *q)\n{\n\tif (shmq_check_memory(q)) {\n\t\treturn q->width;\n\t}\n\treturn -1;\n}\n\nbool shmq_isfull(const struct shmqueue *q)\n{\n\treturn (shmq_check_memory(q) && q->front != -1 && (q->rear + 1) % q->size == q->front);\n}\n\nbool shmq_isempty(const struct shmqueue *q)\n{\n\treturn shmq_check_memory(q) && (q->front == -1);\n}\n\nint shmq_data_total_memory(const struct shmqueue *q)\n{\n\tif (shmq_check_memory(q)) {\n\t\treturn shmq_size(q) * shmq_width(q);\n\t}\n\treturn -1;\n}\n\nvoid *shmq_dequeue(struct shmqueue *q)\n{\n\tvoid *ptr = NULL;\n\n\tif (shmq_check_memory(q) && q->front != -1) {\n\t\tmlock(q, sizeof(*q));\n\t\tmlock(q->data, (q->size + 1) * q->width);\n\n\t\tptr = q->data + (q->front * q->width);\n\n\t\tif (q->front == q->rear) {\n\t\t\tq->front = q->rear = -1;\n\t\t} else {\n\t\t\tq->front = (q->front + 1) % q->size;\n\t\t}\n\n\t\tmunlock(q, sizeof(*q));\n\t\tmunlock(q->data, (q->size + 1) * q->width);\n\n\t\treturn ptr;\n\t}\n\n\treturn NULL;\n}\n\nint shmq_enqueue(struct shmqueue *q, const void *data)\n{\n\tif (!shmq_check_memory(q)) {\n\t\treturn -1;\n\t}\n\n\tmlock(q, sizeof(*q));\n\tmlock(q->data, (q->size + 1) * q->width);\n\n\tif (shmq_isfull(q)) {\n\t\tshmq_dequeue(q);\n\t} else if (q->front == -1) {\n\t\tq->front = 0;\n\t}\n\n\tq->rear = (q->rear + 1) % q->size;\n\n\tif (!__shmq_index_check(q)) {\n\t\treturn -1;\n\t}\n\n\tmemcpy((char*)q->data + (q->rear * q->width), data, q->width);\n\tmsync(q->data, (q->size + 1) * q->width, MS_SYNC);\n\n\tmunlock(q->data, (q->size + 1) * q->width);\n\tmunlock(q, sizeof(*q));\n\n\treturn q->rear;\n}\n\nint shmq_enqueue_unique(struct shmqueue *q,\n\t\t\tconst void *data,\n\t\t\tint (*compar)(const void *, const void *, size_t n))\n{\n\tif (!shmq_check_memory(q)) {\n\t\treturn -1;\n\t}\n\n\tif (shmq_has_data(q, data, compar)) {\n\t\tshmq_errnum = SHMQ_ERR_DATA_DUP;\n\t\treturn -1;\n\t}\n\n\treturn shmq_enqueue(q, data);\n}\n\nvoid *shmq_data_at(const struct shmqueue *q, const int idx)\n{\n\tif (shmq_check_memory(q) == false || q->front == -1) {\n\t\treturn NULL;\n\t}\n\n\treturn (char *)q->data + idx * (q->width);\n}\n\nbool shmq_has_data(const struct shmqueue *q,\n\t\t   const void\t      *data,\n\t\t   int (*compar)(const void *, const void *, size_t n))\n{\n\tbool ok;\n\tif (!shmq_check_memory(q) || shmq_isempty(q)) {\n\t\treturn false;\n\t}\n\n\tmlock(q->data, (q->size + 1) * q->width);\n\tmlock(q, sizeof(*q));\n\n\tint i = q->rear;\n\tif ((ok = (compar(shmq_data_at(q, i), data, q->width) == 0))) {\n\t\tgoto finish;\n\t}\n\n\tfor (i = q->front; i != q->rear; i = (i + 1) % q->size) {\n\t\tif ((ok = (compar(shmq_data_at(q, i), data, q->width) == 0))) {\n\t\t\tgoto finish;\n\t\t}\n\t}\n\nfinish:\n\n\tmunlock(q->data, (q->size + 1) * q->width);\n\tmunlock(q, sizeof(*q));\n\n\treturn ok;\n}\n\nconst char *shmq_strerror()\n{\n\tstatic char errmsg[256] = {0};\n\tswitch (shmq_errnum) {\n\tcase SHMQ_ERR_OPEN:\n\t\tsnprintf(errmsg,\n\t\t\t sizeof(errmsg),\n\t\t\t "%s: %s",\n\t\t\t "shm_open failed",\n\t\t\t strerror(errno));\n\t\tbreak;\n\n\tcase SHMQ_ERR_TRUNC:\n\t\tsnprintf(errmsg,\n\t\t\t sizeof(errmsg),\n\t\t\t "%s: %s",\n\t\t\t "ftruncate failed",\n\t\t\t strerror(errno));\n\t\tbreak;\n\n\tcase SHMQ_ERR_MMAP:\n\t\tsnprintf(errmsg,\n\t\t\t sizeof(errmsg),\n\t\t\t "%s: %s",\n\t\t\t "mmap failed",\n\t\t\t strerror(errno));\n\t\tbreak;\n\n\tcase SHMQ_ERR_MEM_CHECK_FAIL:\n\t\tsnprintf(errmsg,\n\t\t\t sizeof(errmsg),\n\t\t\t "%s: %s",\n\t\t\t "shmq_check_memory failed",\n\t\t\t strerror(errno));\n\t\tbreak;\n\n\tcase SHMQ_ERR_DATA_DUP:\n\t\tsnprintf(\n\t\t    errmsg, sizeof(errmsg), "shmqueue has the same data\\n");\n\t\tbreak;\n\n\tcase SHMQ_ERR_INDEX_OUTRANGE:\n\t\tsnprintf(\n\t\t    errmsg, sizeof(errmsg), "check shmqueue index failed\\n");\n\t\tbreak;\n\n\tdefault:\n\t\tsnprintf(errmsg, sizeof(errmsg), "%s", "success");\n\t\tbreak;\n\t}\n\n\treturn errmsg;\n}\n'})})]})}function h(t={}){const{wrapper:n}={...(0,i.R)(),...t.components};return n?(0,r.jsx)(n,{...t,children:(0,r.jsx)(c,{...t})}):c(t)}},28453:(t,n,e)=>{e.d(n,{R:()=>m,x:()=>o});var s=e(96540);const r={},i=s.createContext(r);function m(t){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof t?t(n):{...n,...t}}),[n,t])}function o(t){let n;return n=t.disableParentContext?"function"==typeof t.components?t.components(r):t.components||r:m(t.components),s.createElement(i.Provider,{value:n},t.children)}}}]);