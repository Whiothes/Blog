"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1809],{80801:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"TOC/computer/kernel/lkd/ch12","title":"\u7b2c 12 \u7ae0 \u5185\u5b58\u7ba1\u7406","description":"Page Tables \u2014 The Linux Kernel documentation","source":"@site/docs/TOC/computer/kernel/lkd/ch12.md","sourceDirName":"TOC/computer/kernel/lkd","slug":"/TOC/computer/kernel/lkd/ch12","permalink":"/docs/TOC/computer/kernel/lkd/ch12","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"\u7b2c 8 \u7ae0 \u4e0b\u534a\u90e8\u548c\u63a8\u540e\u6267\u884c\u7684\u5de5\u4f5c","permalink":"/docs/TOC/computer/kernel/lkd/ch08"},"next":{"title":"System","permalink":"/docs/category/system"}}');var s=t(74848),r=t(28453);const a={},o="\u7b2c 12 \u7ae0 \u5185\u5b58\u7ba1\u7406",c={},l=[{value:"12.1 \u9875",id:"121-\u9875",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"\u7b2c-12-\u7ae0-\u5185\u5b58\u7ba1\u7406",children:"\u7b2c 12 \u7ae0 \u5185\u5b58\u7ba1\u7406"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://docs.kernel.org/mm/page_tables.html",children:"Page Tables \u2014 The Linux Kernel documentation"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"121-\u9875",children:"12.1 \u9875"}),"\n",(0,s.jsxs)(n.p,{children:["v6.7.0 ",(0,s.jsx)(n.code,{children:"<linux/mm_types.h>"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"struct page {\n unsigned long flags;  /* Atomic flags, some possibly\n      * updated asynchronously */\n\n  /* union \u5220\u53bb\u4e86 union */\n\n /* Usage count. *DO NOT USE DIRECTLY*. See page_ref.h */\n atomic_t _refcount;\n\n#ifdef CONFIG_MEMCG\n unsigned long memcg_data;\n#endif\n\n /*\n  * On machines where all RAM is mapped into kernel address space,\n  * we can simply calculate the virtual address. On machines with\n  * highmem some memory is mapped into kernel virtual memory\n  * dynamically, so we need a place to store that address.\n  * Note that this field could be 16 bits on x86 ... ;)\n  *\n  * Architectures with slow multiplication can define\n  * WANT_PAGE_VIRTUAL in asm/page.h\n  */\n#if defined(WANT_PAGE_VIRTUAL)\n void *virtual;   /* Kernel virtual address (NULL if\n        not kmapped, ie. highmem) */\n#endif /* WANT_PAGE_VIRTUAL */\n\n#ifdef LAST_CPUPID_NOT_IN_PAGE_FLAGS\n int _last_cpupid;\n#endif\n\n#ifdef CONFIG_KMSAN\n /*\n  * KMSAN metadata for this page:\n  *  - shadow page: every bit indicates whether the corresponding\n  *    bit of the original page is initialized (0) or not (1);\n  *  - origin page: every 4 bytes contain an id of the stack trace\n  *    where the uninitialized value was created.\n  */\n struct page *kmsan_shadow;\n struct page *kmsan_origin;\n#endif\n} _struct_page_alignment;\n"})})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var i=t(96540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);