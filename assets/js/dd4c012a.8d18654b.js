"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[882],{74579:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"TOC/language/C++/C++_Primer/ch02","title":"Chapter 2. Variables and Basic Types","description":"2.1. Primitive Built-in Types","source":"@site/docs/TOC/language/C++/C++_Primer/ch02.md","sourceDirName":"TOC/language/C++/C++_Primer","slug":"/TOC/language/C++/C++_Primer/ch02","permalink":"/docs/TOC/language/C++/C++_Primer/ch02","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Programming Language","permalink":"/docs/category/programming-language"},"next":{"title":"Chapter 3. Strings, Vectors, and Arrays","permalink":"/docs/TOC/language/C++/C++_Primer/ch03"}}');var s=t(74848),r=t(28453);const c={},l="Chapter 2. Variables and Basic Types",d={},o=[{value:"2.1. Primitive Built-in Types",id:"21-primitive-built-in-types",level:2},{value:"2.1.1. Arithmetic Types",id:"211-arithmetic-types",level:3},{value:"2.1.3 Literals",id:"213-literals",level:3},{value:"2.3. Compound Types",id:"23-compound-types",level:2},{value:"2.3.1. References",id:"231-references",level:3},{value:"2.3.2. Pointers",id:"232-pointers",level:3},{value:"Null Pointers",id:"null-pointers",level:4},{value:"2.3.3. Understanding Compound Type Declaractions",id:"233-understanding-compound-type-declaractions",level:3},{value:"2.4. <code>const</code> Qualifier",id:"24-const-qualifier",level:2},{value:"2.4.1. References to const",id:"241-references-to-const",level:2},{value:"2.4.2. Pointers and <code>const</code>",id:"242-pointers-and-const",level:3},{value:"2.4.3. Top-Level <code>const</code>",id:"243-top-level-const",level:3},{value:"2.4.4. <code>constexpr</code> and Constant Expressions",id:"244-constexpr-and-constant-expressions",level:3},{value:"2.5. Dealing with Types",id:"25-dealing-with-types",level:2},{value:"2.5.2. The <code>auto</code> Type Specifier",id:"252-the-auto-type-specifier",level:3},{value:"2.5.3. The <code>decltype</code> Type Specifier",id:"253-the-decltype-type-specifier",level:3},{value:"<code>decltype</code> and References",id:"decltype-and-references",level:4}];function a(e){const n={blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"chapter-2-variables-and-basic-types",children:"Chapter 2. Variables and Basic Types"})}),"\n",(0,s.jsx)(n.h2,{id:"21-primitive-built-in-types",children:"2.1. Primitive Built-in Types"}),"\n",(0,s.jsx)(n.h3,{id:"211-arithmetic-types",children:"2.1.1. Arithmetic Types"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Meaning"}),(0,s.jsx)(n.th,{children:"Minimum Size"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"bool"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"NA"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"char"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"8 bits"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"wchar_t"})}),(0,s.jsx)(n.td,{children:"wide character"}),(0,s.jsx)(n.td,{children:"16 bits"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"char16_t"})}),(0,s.jsx)(n.td,{children:"unicode character"}),(0,s.jsx)(n.td,{children:"16 bits"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"char32_t"})}),(0,s.jsx)(n.td,{children:"unicode character"}),(0,s.jsx)(n.td,{children:"32 bits"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"short"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"16 bits"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"int"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"32 bits"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"long"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"64 bits"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"long long"}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{children:"64 bits"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"float"}),(0,s.jsx)(n.td,{}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:"6"})," sinificant bits"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"double"}),(0,s.jsx)(n.td,{}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:"10"})," significant bits"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"long double"}),(0,s.jsx)(n.td,{}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:"10"})," significant bits"]})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"213-literals",children:"2.1.3 Literals"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"  L'a'\t\t\t// wide character literal, type is wchar_t\n  u8\"hi!\"\t\t// utf-8 string literal (utf-8 encodes a Unicode character in 8bits)\n  42ULL\t\t\t// unsigned integer literal, type is unsigned long long\n  1E-3F\t\t\t// single-precision floating-point literal, float\n  3.14159L\t// extended-precision floating-point literal, double\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Best Practice"})}),"\n",(0,s.jsxs)(n.p,{children:["\u200b\tuse uppercase ",(0,s.jsx)(n.code,{children:"L"}),"  when write ",(0,s.jsx)(n.code,{children:"long"})," literal, ",(0,s.jsx)(n.code,{children:"l"})," is easily mistaken for the digit ",(0,s.jsx)(n.code,{children:"1"})]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"23-compound-types",children:"2.3. Compound Types"}),"\n",(0,s.jsx)(n.h3,{id:"231-references",children:"2.3.1. References"}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.em,{children:"reference"})," defines an alternative name for an object."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"int ival = 1024;\nint &refVal1 = ival;    // refVal refers to (is another name for) ival\nint &refVal2;\t\t\t\t\t\t// error: a reference must be initialized\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Note"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"A reference is not an object."})," Instead, a reference is just ",(0,s.jsx)(n.strong,{children:"another name"})," for an ",(0,s.jsx)(n.strong,{children:"already existing"})," object."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"232-pointers",children:"2.3.2. Pointers"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"int ival = 42;\nint *p = &ival; // p holds the address of ival: p is a pointer to ival\n"})}),"\n",(0,s.jsx)(n.h4,{id:"null-pointers",children:"Null Pointers"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"int *p1 = nullptr; // equivalent to int *p1 = 0;\nint *p2 = 0;       // directly initializes p2 from the literal constant 0\nint *p3 = NULL;    // equivalent to int *p3 = 0;\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"nullptr"})," is a literal that has a special type that can be converted to any other pointer type,."]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Advice: Initialize all Pointers"}),"\n",(0,s.jsx)(n.p,{children:"Uninitialized pointers are a common source of run-time errors."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.strong,{children:["The most important differences between ",(0,s.jsx)(n.em,{children:"reference"})," and ",(0,s.jsx)(n.em,{children:"pointer"})," is a reference is not an object. There is no way to make a defined reference refer to a different object."]})}),"\n",(0,s.jsx)(n.h3,{id:"233-understanding-compound-type-declaractions",children:"2.3.3. Understanding Compound Type Declaractions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"int i = 1024, *p = &i, &r = i;\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Tip"}),"\n",(0,s.jsx)(n.p,{children:"There is no single right way to define pointers or references. The important thing is to choose a style and use it consistently."}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"24-const-qualifier",children:["2.4. ",(0,s.jsx)(n.code,{children:"const"})," Qualifier"]}),"\n",(0,s.jsx)(n.p,{children:"Define a variable whose value cannot be changed."}),"\n",(0,s.jsx)(n.h2,{id:"241-references-to-const",children:"2.4.1. References to const"}),"\n",(0,s.jsxs)(n.p,{children:["A reference to ",(0,s.jsx)(n.code,{children:"const"})," cannot be used to change the object to which the reference is bound."]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Terminology: ",(0,s.jsx)(n.code,{children:"const"})," Reference is a Reference to ",(0,s.jsx)(n.code,{children:"const"})]}),"\n",(0,s.jsxs)(n.p,{children:["There are no ",(0,s.jsx)(n.code,{children:"const"})," references. A reference is not an object, so we cannot make a reference itself ",(0,s.jsx)(n.code,{children:"const"}),". in some sense all references are ",(0,s.jsx)(n.code,{children:"const"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"double dval = 3.14;\nconst int &ri = dval;\n\n\n// Transform\nconst int temp = dval; // create a temporay const int from the double \nconst int &ri = temp; // bind ri to that temporary\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"242-pointers-and-const",children:["2.4.2. Pointers and ",(0,s.jsx)(n.code,{children:"const"})]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.strong,{children:"pointer to const"})," may not be used to change the object to which the pointer points."]}),"\n",(0,s.jsxs)(n.p,{children:["We may store the address of a ",(0,s.jsx)(n.code,{children:"const"})," object only in a pointer to ",(0,s.jsx)(n.code,{children:"const"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"const double pi = 3.14; \ndouble *ptr = &pi; // error;\nconst double *cptr = &pi; // ok\n*cptr = 42; // error: cannot assign to *cptr\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"243-top-level-const",children:["2.4.3. Top-Level ",(0,s.jsx)(n.code,{children:"const"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"top-level const"})," indicate that the pointer itself is a ",(0,s.jsx)(n.code,{children:"const"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"low-level const"})," indicate a pointer can point to a ",(0,s.jsx)(n.code,{children:"const"})," object."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"int i = 0;\nint *const p1 = &i; // we can't change the value of p1; const is top-level\nconst int ci = 42; \nconst int *p2 = &ci; // we can change p2; const is low-level\nconst int *const p3 = p2; // right-most const is top-level, left-most is not \nconst int &r = ci; // const in reference types is always low-level\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"244-constexpr-and-constant-expressions",children:["2.4.4. ",(0,s.jsx)(n.code,{children:"constexpr"})," and Constant Expressions"]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.strong,{children:"constant expression"})," is an expression whose value cannot change and that can be evaluated at compile time."]}),"\n",(0,s.jsx)(n.h2,{id:"25-dealing-with-types",children:"2.5. Dealing with Types"}),"\n",(0,s.jsxs)(n.h3,{id:"252-the-auto-type-specifier",children:["2.5.2. The ",(0,s.jsx)(n.code,{children:"auto"})," Type Specifier"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"auto"}),": let the compiler figure out the type for use"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// the type of item is deduced from the type of the result of adding val1 and val2\nauto item = val1 + val2; // item initialized to the result of val1 + v2\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"253-the-decltype-type-specifier",children:["2.5.3. The ",(0,s.jsx)(n.code,{children:"decltype"})," Type Specifier"]}),"\n",(0,s.jsx)(n.p,{children:"returns the type of its operand."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"decltype(f()) sum = x;\n"})}),"\n",(0,s.jsx)(n.p,{children:"the compiler does not call f, but it uses the type that such a call would return as the type for sum."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"const int ci = 0, &cj = ci;\ndecltype(cj) x = 0; // x has type const int \ndecltype(cj) y = x; // y has type const int& and is bound to x\ndecltype(cj) z; // error: z is a reference and must be initialized\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"decltype-and-references",children:[(0,s.jsx)(n.code,{children:"decltype"})," and References"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// decltype of an expression can be a reference type\nint i = 42, *p = &i, &r = i;\ndecltype(r+0) b; // ok: additional yields an int; b is an (unintialized) int\ndecltype(*p) c; // error: c is int& and must be initialized\n\n// decltype of a parenthesized variable is always a reference\ndecltype((i)) d; // error: d is int& and must be initizlied\ndecltype(i) e; // ok: e is an (unintialized) int \n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Warning"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"decltype"}),"''((variable)) (not, double, parentheses) is always a reference type, but ",(0,s.jsx)(n.code,{children:"decltype"}),"(variable) is a reference type only if variable is a reference."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>l});var i=t(96540);const s={},r=i.createContext(s);function c(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);